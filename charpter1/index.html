<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>场景，模型，光照，变换,位置偏移</title>
    <script src="../three.min.js"></script>
</head>
<body onload="main()">

<script>
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = (function() {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
                    window.setTimeout(callback, 1000/60);
                };
        })();
    }

    function main(){
        initScene();
        initRenderer();
        initCamera();
        initLight();
        initMaterial();
        initMesh();
        animate();
    }
    /**
     * 一、3大组建：场景（scene）、相机（camera）和渲染器（renderer）
     */

    var scene,camera,renderer;
    function initScene(){
         scene  = new THREE.Scene();
        /**
         * 雾化，场景使用同一材质
         */
//    scene.fog=new THREE.Fog(0x00f000,100,1000)
//    scene.overrideMaterial = new THREE.MeshLambertMaterial({color:0x7777ff})
    }
    function initRenderer(){
         renderer = new THREE.WebGLRenderer({
            antialias:true
        });
        renderer.setClearColor(0xeeeeee, 1.0);
        renderer.setSize(window.innerWidth,window.innerHeight);
   //    renderer.shadowMapEnabled = true;//开启阴影
  //renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 默认的是，没有设置的这个清晰 THREE.PCFShadowMap
        document.body.appendChild(renderer.domElement);
    }
    function initCamera(){
         camera = new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,0.1,1000,1.5);
        /**
         * 相机基本概念，上方向，焦点，上方向设置在焦点之前
         * 正交摄像机，透视摄像机
         */
        camera.position.y = 200;
        camera.position.z = 350; //注意，相机位置必须大于最近点
        camera.position.x = 0;
        camera.up.x = 0;//相机以哪个方向为上方
        camera.up.y = 1;
        camera.up.z = 0;
        camera.lookAt(0,0,0)

    }

    function setCameraFov(fov)
    {
        camera.fov = fov;
        camera.updateProjectionMatrix();
    }



    /**
     * 二、光照：点光，聚光（阴影）平行光（阴影），环境光
     */

    var spotLight,directLight,ambientLight;
    function initLight(){
        //点光
        spotLight = new THREE.SpotLight(0xffffff);
        spotLight.position.set(0,200,0);
        spotLight.castShadow=true;
        //平行光
        directLight = new THREE.DirectionalLight(0xffffff);
        //环境光
        ambientLight = new THREE.AmbientLight(0x0c0c0c);
        scene.add(spotLight)
//        scene.add(ambientLight)
//        scene.add(directLight)
    }


    /**
     * 三、材质，纹理，贴图
     */

    var sphereMaterial,wireframe,circleMaterial;
    function initMaterial(){
         sphereMaterial = new THREE.MeshLambertMaterial({color:0xffffff});
         wireframe=new THREE.MeshBasicMaterial({color:0x000000,wireframe:true});
         circleMaterial = new THREE.LineDashedMaterial({
             color: 0xff0000,
             dashSize: 12,
             gapSize: 12,

         });
    }

    /**
     * 三维对象：平面，方块，球体，摄像机，轴
     * 注意，模型看不见原因很可能是模型位置在摄像机外，或者相机在模型体内
     */

    var sphere,meshGroup,plan;
    function initMesh(){
        //辅助线
        function drawHelper(){
            scene.add(new THREE.AxesHelper(200));//坐标轴
            scene.add( new THREE.GridHelper( 1000, 40 , 0x0000ff, 0x808080) );//平面网格
        }
        /**
         *创建网格Mesh  支持postion,rotation,visible,
         *    sphere.translateOnAxis(new THREE.Vector3(1,0,0),100);
         */
        /**
         * 添加线框两种方式
         * THREE.SceneUtils.createMultiMaterialObject
         * HREE.WireframeHelper
         */
       function drawSphere(){
           var sphereGemometry = new THREE.SphereGeometry(20,40,40);
           sphereGemometry.translate(100,0,0);
           sphere = new THREE.Mesh(sphereGemometry,sphereMaterial);
           sphere.position.y=20;
           sphere.castShadow=true;
           meshGroup = THREE.SceneUtils.createMultiMaterialObject(sphereGemometry,[sphereMaterial,wireframe] );
           meshGroup.position.y=20;
            scene.add(meshGroup)
//           scene.add(new THREE.WireframeHelper(sphere,0x000000));
       }
       function drawPlane(){
           var planeGemometry = new THREE.PlaneGeometry(460,360);
           var plan = new THREE.Mesh(planeGemometry,sphereMaterial);
           plan.receiveShadow=true;
           plan.rotation.x=-Math.PI/2
           scene.add(plan)
       }
       function drawCirle(){
            var geometry = new THREE.CircleGeometry(140, 64);
            console.log(geometry)
//            geometry.vertices.shift();
           var mesh =new THREE.Line(geometry, circleMaterial)
            mesh.rotation.x=-Math.PI/2
            scene.add(mesh);
        }
        drawSphere();
        drawPlane();
        drawCirle();
    }


    /**
     * 动画
     */
    var animate = function () {
        if(meshGroup){
            meshGroup.rotation.y += 0.04
        }
        renderer.render( scene, camera );
        requestAnimationFrame( animate );
    };


</script>
</body>
</html>